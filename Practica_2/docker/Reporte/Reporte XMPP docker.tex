\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}

\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\graphicspath{ {/home/jsebastian-ar/Documentos/Latex_images/Prosody/} }
\usepackage[export]{adjustbox}

\begin{document}
\title{Montar Servidor XMPP y BD de postgresql en Contenedor Docker}
\author{Acosta Rosales Jair Sebastián}
\date{\today}
\maketitle

\section{Introducción XMPP}
XMPP, cuyo significado es Extensible Messaging and Presence Protocol, es un protocolo de mensajeria basado en XML, el cual permite un servicio de mensajerio entre usuarios que permite 

\section{Descargando imagen Docker para Postgresql 11.4}

Para este apartado no se creará un archivo Dockerfile para postgresql, en lugar de ello se implementará una imagen oficial desde la página \url{https://hub.docker.com} en donde es posible encontrar imagenes de múltiples servicios, uno de ellos de bases de datos, como lo pueden ser el propio postgrsql, mysql, etc.

Por lo tanto, al acceder a la página hub.docker.com y buscar postgresql, deberá aparecer lo siguiente:\\


\begin{figure}[htb]
\centering
\includegraphics[scale=.3]{postgresql1}
\end{figure}

El cual es la imagen oficial para postgresql, haciendo click a este enlace nos dirigira al sitio con todas las imagenes posibles para descargar e implementar en docker, iremos al apartado de la derecha donde se encuentra un comando de docker, en la parte de abajo habrá un enlace con lo siguiente \textbf{View Available Tags} lo que significa que ahí podremos ver las versiones disponibles de postgresql, y descargar la que deseemos.

\begin{center}
\includegraphics[scale=.5]{postgresql2}
\end{center}

Para este ejemplo se busco y se selecciono la versión 11.4 de postgresql, en la siguiente imagen podemos observar el comando con el cual podemos descargar esta imagen, ubicado en la esquina superior derecha, el cual es: \textbf{docker pull postgres:11.4}\\

\begin{center}
\centering
\includegraphics[scale=.3]{postgresql3}
\end{center}

Ejecutando el comando en consola esperaremos a que la imagen sea descargada en nuestra computadora y poder crear un contenedor con este.

\begin{center}
\includegraphics[scale=.4]{postgresql4}\\
En esta imagen se hizo el pull con la versión 11.7 de postgresql
\end{center}

Una vez descargado la nueva imagen procedemos a revisar las imagenes disponibles en nuestra version local de docker, con el comando \textbf{docker images}, donde se desplegará la lista de todas las imágenes disponibles.

\begin{center}
\includegraphics[scale=.5]{postgresql5}
\end{center}

Así podemos corroborar que tenemos la imagen de postgresql para su futuro uso en un contenedor.

\section{Creación de imagen Docker para servidor XMPP}

Para la creación de una imagen personalizada del servidor XMPP, se hará uso del servidor Prosody, del cual se obtuvo un Dockerfile de la siguiente dirección: \url{https://github.com/prosody/prosody-docker}, que requiere de la descarga del archivo .deb para la instalación del servidor prosody, el cual se puede obtener en: \url{https://debian.pkgs.org/10/debian-main-amd64/prosody_0.11.2-1_amd64.deb.html}, siendo la versión de debian, pues el SO base que será usado para esta imagen será Debian 10, sin embargo, hubo ciertas modificaciones a este archivo, las cuales se listan:

\begin{itemize}
\item \textbf{Se elimino el entrypoint}\\
La imagen que es creada mediante el dockerfile requiere de un entrypoint que debe usarse cuando el comando \textbf{docker run} para la creación del contenedor es ejecutado, el entrypoint es ejecutado dentro de las instrucciones del dockerfile y para que el servidor sea iniciado, un parámetro extra debe agregarse al comando "docker run", si el parámetro es agregado y el entrypoint lo reconoce, el servidor se inicia, si el entrypoint no lo detecta, entonces el servidor no se inicia y el contenedor muere a los pocos segundos de haber sido iniciado, pues no tiene un proceso en ejecución para que siga viviendo.

La gran desventaja de trabajar con ese entrypoint es que cuando el contenedor es creado y se ejecuta correctamente(con el servidor XMPP funcionando), este contenedor no podía ser detenido(docker stop) o reiniciado(docker restart), pues cuando el contenedor quisiese iniciarse nuevamente, el entrypoint se ejecutaria y lo que sucederia es que necesita pasar el parametro para iniciar el servidor, cosa que en un comando como \textbf{docker start} o \textbf{docker restart}, no es posible pasar parámetros.

\item Comandos de edición del archivo de configuracion \textbf{prosody.cfg.lua}, dado que ya se poseían esos archivos con la configuración deseada, por lo que era más fácil realizar un COPY de archivos dentro del Dockerfile, que la ejecución de comandos para editar los archivos.

\item Se eliminaron el resto de puertos a ser expuestos, manteniendo solo el puerto 5222.
\end{itemize}

De modo que el archivo de configuración ha quedado de la siguiente forma:

\begin{center}
\includegraphics[scale=.5]{prosody1}
\end{center}

En el podemos observar las distintas partes de instrucciones que lo conforman:
\begin{enumerate}
\item El SO base será Debian 10

\item Las dependencias requeridas para el servidor, como los certificados ssl, los modulos de configuración de bases de datos, el editor nano para poder visualizar los archivos y verificar su configuración, la paquetería que permite visualizar las interfaces con el comando \textbf{ifconfig}, todos estos paquetes instalados bajo la bandera -y, la cual hace referencia a la palabra "yes" e indica que estamos deacuerdo con instalar los paquetes, asimismo indicamos que no se instalen paquetes recomendados de debian que pueden aparecer en la pantalla al momento de crear la imagen.

\item Se copia y pega dentro del ambiente el paquete prosody.deb, el cual permitira instalar el servidor XMPP, además de que se ejecuta el comando correspondiente para la instalación de este.

\item Se copian y pegan tres archivos previamente configurados o creados, los cuales son:
	\begin{itemize}
	\item \textbf{prosody.cfg.lua}: Contiene toda la configuración del funcionamiento de nuestro servidor, es copiado en la ruta correspondiente donde se instalaría normalmente los archivos de configuración de prosody, es decir /etc/prosody.
	\item \textbf{docker.com.crt}: Es el certificado de seguridad ssl creado específicamente para el servidor, el cual permite cifrar los mensajes que los usuarios se estén enviando entre si.
	\item \textbf{docker.com.key}: El archivo key es generado junto con el archivo .ctr y contiene la llave de cifrado de mensajes.
	\end{itemize}

\item Una vez que los archivos son copiados, el comando \textbf{chown} es ejecutado para estos, con la finalidad de que el usuario "prosody" pueda leerlos y ejecutarlos.

\item Se crea la carpeta donde se almacenara el archivo .pid del proceso de prosody, este archivo pid contendrá el id único del proceso en el contenedor, \textbf{nota: Se identifico que sin está instrucción el servidor no es capaz de mantenerse activo, se especula que es debido a que necesita de esta carpeta para poder almacenar el id del proceso y por lo tanto poder asignarle uno.}

\item Se expone el puerto 5222, visible para otros contenedores.

\item Como intrucción final se configura para que el comando ejecutado en consola sea \textbf{prosodyctl start} lo cual permite iniciar el servidor y por lo tanto, permite que el servicio se ejcute y mantenga vivo el contenedor, esta intrucción sustituye al entrypoint, que como se explico, traía consigo desventajas, pero con esta instrucción es posible detener o reiniciar la ejecución de un contenedor y que este al ser iniciado pueda ejecutarse sin problemas.
\end{enumerate}

Una vez terminado de configurar el Dockerfile, se procede con la creación de la imagen correspondiente, a través del comando \textbf{docker build file\_path\_Dockerfile -t name:tag}.

Donde:

\begin{itemize}
\item \textbf{file\_path\_Dockerfile}: Es la ruta de la carpeta donde se encuentra ubicado el Dockerfile
\item \textbf{-t}: Esta bandera hace referencia a que se agregara un tag en especial para identificar entre imágenes que posean el mismo nombre.
\item \textbf{name:tag}: La parte name hace referencia al nombre que se le dará a la imagen, mientras que tag será la etiqueta única que identificará a esa imagen entre otras posibles con el mismo nombre.
\end{itemize}

Finalmente al crear la imagen:

\begin{center}
\includegraphics[scale=.5]{prosody2}
\end{center}

\begin{center}
\includegraphics[scale=.5]{prosody3}
\end{center}

Obtenemos un mensaje exitoso de que la creación de la imagen ha terminado y si revisamos las imagenes con el comando \textbf{docker images}.

\begin{center}
\includegraphics[scale=.5]{prosody4}
\end{center}

\section{Creacion de subred para la conexión entre contenedores}
Se creará una subred interna de docker del tipo bridge, con la finalidad de que ambos contenedores se encuentren en la misma red y puedan comunicarse entre si a través de sus direcciones ip.

Lo anterior se puede crear con el siguiente comando:\\

\textbf{docker network create --driver bridge --subnet subred\_deseada nombre\_de\_red}

Lo anterior se puede entender de la siguiente forma:

\begin{enumerate}
\item \textbf{--driver bridge}: Esta bandera indica el tipo de red a la que estará conectado el contenedor, existen tres tipos:
	\begin{itemize}
		\item \textbf{NONE}: Este tipo de red indica que será una red aislada, en la que el contenedor conectado no tendrá acceso ni a las interfaces de la computadora donde está ejecutandose ni tampoco a la comunicación con otros contenedores.
		
		\item \textbf{HOST}: Este tipo de red, permite al contenedor tener acceso y conectividad a todas las interfaces de red, de la computadora donde se está ejecutando.
		
		\item \textbf{BRIDGE}: Este tipo de red permite tanto conectividad con las interfaces de red de la computadora donde se está ejecutando y comunicación con otros contenedores.
		
Para este caso, nosotros deseamos conectividad con otro contenedor XMPP,aunque no necesariamente que la BD este expuesta a otros servicios, pues solo el servidor Prosody se comunicará con este contenedor, de este modo se elige el tipo de subred bridge.
	\end{itemize}

\item \textbf{--subnet subred\_deseada}: Esta bandera nos permitirá indicar de que subred se tratará, así como las direcciones disponibles en ella, de modo que subred deseada será \textbf{192.168.10.0/24} con la notación \textbf{/24} indicando el número de bits que ocupará para la parte de la red, dejando el último octeto para los hosts disponibles en la red.

\item \textbf{nombre\_de\_red}: Este será el nombre que deseamos darle a la red para identificarla.
\end{enumerate}

Para este caso el comando quedará de la siguiente manera.\\

\textbf{docker network create --driver bridge --subnet 192.168.10.0/24 prosodynet}\\

Una vez ejecutado el comando anterior podemos listar las redes de docker y notar que tenemos la nueva red.

\begin{center}
\includegraphics[scale=.5]{subnet1}
\end{center}

\begin{center}
\includegraphics[scale=.5]{subnet2}\\
Observamos más a detalle la información de la subred
\end{center}

\section{Creación y configuración de los contenedores}
Una vez que se tienen las imágenes, procederemos a crear los contenedores para la ejecución de los servicios.

\subsection{Contenedor de Postgresql}

Para la creación del contenedor de postgresql, se ejecutara el siguiente comando:\\

\textbf{docker run -d --name nombre\_contenedor --subnet nombre\_subred --ip dir\_ip nombre\_imagen}\\

Donde:

\begin{enumerate}
\item \textbf{-d}: Bandera que ejecuta la acción en \textit{detached mode}, esto significa que el contenedor y servidor se ejecutara pero de forma oculta, no será posible funcionar el contenedor al momento de ejecutar el comando. 

\item \textbf{--name}: Permite asignar un nombre al contenedor

\item \textbf{--subnet}: Permite asignar la subred a la que deseamos que el contenedor pertenezca (aquí se especificara la subred que creamos).

\item \textbf{--ip}: Permite especificar la dirección ip que deseamos que tenga el contenedor, esto será útil para realizar la conexión entre ambos contenedores, pues en el archivo de configuración de Prosody \textit{Prosody.cfg.lua} debemos especificar la ip donde se encuentra la base de datos.

\begin{center}
\label{configdb}
\includegraphics[scale=.5]{container1}\\
Línea de configuración de la BD en el archivo Prosody.cfg.lua
\end{center}

\item \textbf{nombre\_imagen}: Nombre de la imagen a la que le será creado un contenedor.

\end{enumerate}

Finalmente el comando queda de la siguiente manera:\\

\textbf{docker run -d --name bdpg --subnet prosodynet --ip 192.168.10.3 postgres:11.4}\\

Una vez ejecutado, podemos verlo en ejecución con ayuda del comando \textit{docker ps}

\begin{center}
\includegraphics[scale=.3]{container2}
\end{center}

Con el comando \textit{docker inspect nombre\_contenedor} podremos ver las especificaciones de un contenedor en particular, en este caso "bdpg". En la siguiente imagen se observan las especificaciones de la red a la que fue asignado y su ip, como era de esperarse.

\begin{center}
\includegraphics[scale=.4]{container3}
\end{center}

\subsection{Configuración de contenedor bdpg}

Una vez creado el contenedor, procedemos a crear la base de datos donde serán almacenados los mensajes que el servidor XMPP reciba y envie. Para ello accederemos al contenedor con el comando \textbf{docker exec -it bdpg bash}, este comando nos permite acceder a la consola del contenedor para poder observar su funcionamiento.

\begin{center}
\includegraphics[scale=.4]{cfgcontainer1}
\end{center}

Ahora procedemos a ejecutar el comando para crear la base de datos, el cual es: \textit{createdb -U postgres name\_db}, donde name\_db es el nombre de la base de datos que especificamos en el archivo de configuración \textit{\hyperref[configdb]{Línea de configuración de la BD en Prosody}}

De modo que el comando a ejecutar será:

\begin{center}
\includegraphics[scale=.4]{cfgcontainer2}
\end{center}

Listando las BD del contenedor

\begin{center}
\includegraphics[scale=.4]{cfgcontainer3}
\end{center}

Observamos que la base de datos recién creada no contiene ninguna tabla, pues el servidor Prosody creara automáticamente estas tablas al hacer los primeros registros de mensajes en ella.

\begin{center}
\includegraphics[scale=.5]{cfgcontainer6}
\end{center}

\subsection{Contenedor de Prosody}

Para el contenedor de prosody se ejecutara el siguiente comando

\textbf{docker run -d --name xmpp --subnet prosodynet --ip 192.168.10.2 -p host\_port:container\_port prosody:f}\\

En este comando podemos notar una nueva bandera a diferencia del que se ejecuto para Postgresql, la cual es \textbf{-p}, esta bandera nos permite conectar un puerto de nuestro host(computadora) a un puerto del contenedor a ser creado, en este caso conectaremos el puerto 5222 del contenedor dado que es el predeterminado para el servidor Prosody, y para el servicio XMPP en general. De igual forma, el puerto elegido del host será el 5222.\\

Finalmente el comando queda:

\textbf{docker run -d --name xmpp --subnet prosodynet --ip 192.168.10.2 -p 5222:5222 prosody:f}\\

\begin{center}
\includegraphics[scale=.3]{container4}
\end{center}

\subsection{Configuración de contenedor xmpp}

Ingresando a la consola del contenedor con el comando \textbf{docker exec -it xmpp bash}. Crearemos dos usuarios para el servidor Prosody, de modo que estos puedan mandarse mensajes y estos mensajes sean almacenados en la base de datos en el contenedor \textit{bdpg}.

Para ello ejecutaremos comandos específicos del servidor prosody, como lo es: \textbf{prosodyctl adduser JID}, donde \textbf{JID} es el nombre que le daremos al usuario, pero siempre terminando con el nombre del host virtual  especificado en el archivo de configuración de prosody (en este caso el nombre del host virtual es "docker.com") acompañado de un "@".

\begin{center}
\includegraphics[scale=.6]{cfgcontainer4}\\
Apartado del archivo Prosody.cfg.lua donde se declara el host virtual
\end{center}

\begin{center}
\includegraphics[scale=.5]{cfgcontainer5}\\
Dos usuarios son creados con sus respectivas contraseñas
\end{center}

\section{Configuración de cuentas}

Una vez hechas las configuraciones correspondientes en los contenedores, procedemos a realizar las pruebas de intercambio de mensajes entre dos usuarios, concretamente:

\begin{itemize}
\item \textbf{dsebas-lap@docker.com}: Usuario de laptop, que enviará mensajes a través de la aplicación \textit{Psi}.

\item \textbf{dsebas-mi@docker.com}: Usuario de smartphone, conectado por medio de la aplicación \textit{Bruno the Jabber Bear (XMPP)}.
\end{itemize}

\subsection{Configurando cuenta en Psi}
Para configurar una nueva cuenta en Psi, es necesario seleccionar el ícono de la aplicación y seleccionar la opción "add contact".\\

Procedemos a darle un nombre a la cuenta dentro del equipo.
\begin{center}
\includegraphics[scale=.5]{accounts1}
\end{center}

Ahora se agregará el nombre de la cuenta que fue creada en el servidor prosody (\textit{dsebas-lap@docker.com}) exclusivamente para el usuario de laptop con su respectiva contraseña.

\begin{center}
\includegraphics[scale=.4]{accounts2}
\end{center}

En el apartado connection se da check para especificar la dirección del host (la dirección del equipo donde estarán corriendo los contenedores), para saber su dirección ip, basta con ejecutar en consola el comando \textbf{ifconfig}, además de que se especifica el puerto donde se atenderán las peticiones, mismo puerto que fue conectado al puerto interno del contenedor.

\begin{center}
\includegraphics[scale=.4]{accounts3}
\end{center}

Terminada la configuración procedemos a poner la cuenta en modo online, aparecerá una ventana emergente preguntando si confiamos en los certificados de seguridad del servidor, aceptamos (\textit{Trust this certificate}); después se pedirá que ingresemos la contraseña de nuestra cuenta nuevamente; además pedira llenar un registro con algunos de nuestros datos (bastara con poner nuestro nombre y nickname); y finalmente veremos la cuenta en linea, esto quiere decir que se ha conectado exitosamente al servidor Prosody que se está ejecutando en el contenedor.

\begin{center}
\includegraphics[scale=.4]{accounts4}
\end{center}

\subsection{Configuración de cuenta en Bruno the Jabber Bear (XMPP)}

Al abrir la aplicación deberemos ir al apartado de configuración y posteriormente en configuración de cuenta:

Aquí se agregará la información de la cuenta creada para smartphone desde Prosody (\textit{dsebas-mi@docker.com}) y su respectiva contraseña.

\begin{center}
\includegraphics[scale=.2]{accounts5}
\end{center}

Ahora se agregará la configuración del host

\begin{center}
\includegraphics[scale=.2]{accounts6}
\end{center}

Finalmente se procederá a conectar la cuenta: 

\begin{center}
\includegraphics[scale=.2]{accounts7}
\end{center}

Una vez que ambas cuentas están conectadas, para que ambas cuentas se puedan enviar mensajes, deben agregarse, esto puede ser desde la cuenta en \textit{Psi} o \textit{Bruno}, en este caso se realizo desde Psi.

En el apartado de "add contact", debemos escribir el nombre del usuario (registrado en Prosody) que deseamos agregar a nuestros contactos.

\begin{center}
\includegraphics[scale=.4]{accounts8}
\end{center}

Una vez que lo agregamos, nos llegará una solicitud automática para que el usuario agregado, también nos pueda agregar desde su dispositivo.

\begin{center}
\includegraphics[scale=.5]{accounts9}
\end{center}

Una vez aceptado es posible que ambos desde sus respectivos dispositivos vean al otro y se puedan comunicar.

\begin{center}
\includegraphics[scale=.668]{accounts10}
\includegraphics[scale=.2]{accounts11}
\end{center}

\section{Pruebas}

Ahora ambos dispositivos son capaces de enviarse mensajes.

\begin{center}
\includegraphics[scale=.5]{msg1}
\includegraphics[scale=.2]{msg2}
\end{center}

Observamos que la base de datos ahora tiene nuevas tablas y si listamos los elementos de la tabla \textit{prosodyarchive}, vemos que esta contiene los mensajes intercambiados.

\begin{center}
\includegraphics[scale=.3]{msg3}
\end{center}

\clearpage
Mensajes almacenados

\begin{center}
\includegraphics[scale=.3]{msg4}
\end{center}

\end{document}